package com.empathytraining.data.models

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit

/**
 * Data model representing a user's response to an empathy scenario Stores
 * the user's attempt along with metadata for tracking progress
 *
 * Uses foreign key relationship with EmpathyScenario to maintain data
 * integrity
 */
@Entity(
    tableName = "user_responses", foreignKeys = [ForeignKey(
        entity = EmpathyScenario::class,
        parentColumns = ["scenario_id"],
        childColumns = ["scenario_id"],
        onDelete = ForeignKey.CASCADE // Delete responses if scenario is deleted
    )], indices = [Index(value = ["scenario_id"]), // Index for faster queries by scenario
        Index(value = ["date_created"]) // Index for faster queries by date
    ]
)
data class UserResponse(
    /** Unique identifier for this response Auto-generated by Room database */
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = "response_id") val id: Long = 0,

    /**
     * ID of the scenario this response belongs to Links to EmpathyScenario.id
     * via foreign key
     */
    @ColumnInfo(name = "scenario_id") val scenarioId: Long,

    /**
     * The user's empathetic response text This is what the user typed in
     * response to the scenario
     */
    @ColumnInfo(name = "user_response_text") val userResponseText: String,

    /**
     * When this response was created Stored as ISO string for Room
     * compatibility Use helper methods to work with LocalDateTime
     */
    @ColumnInfo(name = "date_created") val dateCreated: String = LocalDateTime.now().toString(),

    /**
     * How long the user spent thinking/typing (in seconds) Useful for
     * understanding user engagement and difficulty -1 indicates time was not
     * tracked
     */
    @ColumnInfo(name = "response_time_seconds") val responseTimeSeconds: Int = -1,

    /**
     * User's self-rating of their response quality (1-5) Optional field - null
     * if user didn't provide rating 1 = Poor, 5 = Excellent
     */
    @ColumnInfo(name = "self_rating") val selfRating: Int? = null,

    /**
     * Whether the user viewed the example response after submitting Helps
     * track learning engagement
     */
    @ColumnInfo(name = "viewed_example") val viewedExample: Boolean = false,

    /**
     * Number of characters in the response Automatically calculated to track
     * response depth
     */
    @ColumnInfo(name = "response_length") val responseLength: Int = userResponseText.length,

    /**
     * Additional notes or tags the user might add Optional field for user's
     * own reflections
     */
    @ColumnInfo(name = "user_notes") val userNotes: String? = null,
) {

    /**
     * Convert the stored date string back to LocalDateTime
     *
     * @return LocalDateTime representation of when response was created
     */
    fun getCreatedDateTime(): LocalDateTime {
        return try {
            LocalDateTime.parse(dateCreated)
        } catch (e: Exception) {
            LocalDateTime.now() // Fallback to current time if parsing fails
        }
    }

    /**
     * Get a formatted date string for UI display
     *
     * @param pattern DateTimeFormatter pattern (default: "MMM dd, yyyy")
     * @return Formatted date string
     */
    fun getFormattedDate(pattern: String = "MMM dd, yyyy"): String {
        return try {
            getCreatedDateTime().format(DateTimeFormatter.ofPattern(pattern))
        } catch (e: Exception) {
            "Unknown date"
        }
    }

    /**
     * Get a formatted time string for UI display
     *
     * @param pattern DateTimeFormatter pattern (default: "HH:mm")
     * @return Formatted time string
     */
    fun getFormattedTime(pattern: String = "HH:mm"): String {
        return try {
            getCreatedDateTime().format(DateTimeFormatter.ofPattern(pattern))
        } catch (e: Exception) {
            "Unknown time"
        }
    }

    /**
     * Calculate how many days ago this response was created
     *
     * @return Number of days ago (0 for today, 1 for yesterday, etc.)
     */
    fun getDaysAgo(): Long {
        return try {
            ChronoUnit.DAYS.between(
                getCreatedDateTime().toLocalDate(),
                LocalDateTime.now().toLocalDate()
            )
        } catch (e: Exception) {
            0L
        }
    }

    /**
     * Get a human-readable "time ago" string
     *
     * @return String like "Today", "Yesterday", "3 days ago"
     */
    fun getTimeAgoText(): String {
        val daysAgo = getDaysAgo()
        return when (daysAgo) {
            0L -> "Today"
            1L -> "Yesterday"
            in 2L..6L -> "$daysAgo days ago"
            in 7L..13L -> "1 week ago"
            in 14L..29L -> "${daysAgo / 7} weeks ago"
            in 30L..59L -> "1 month ago"
            else -> "${daysAgo / 30} months ago"
        }
    }

    /**
     * Check if this response was created today
     *
     * @return True if response was created today
     */
    fun isFromToday(): Boolean {
        return getDaysAgo() == 0L
    }

    /**
     * Get response quality assessment based on length and self-rating
     *
     * @return Quality descriptor string
     */
    fun getQualityAssessment(): String {
        return when {
            selfRating != null && selfRating >= 4 -> "Great response!"
            selfRating != null && selfRating >= 3 -> "Good response"
            selfRating != null && selfRating >= 2 -> "Decent response"
            responseLength >= 100 -> "Thoughtful response"
            responseLength >= 50 -> "Good length response"
            responseLength >= 20 -> "Brief response"
            else -> "Very brief response"
        }
    }

    /**
     * Get response time description for UI
     *
     * @return Human-readable description of response time
     */
    fun getResponseTimeDescription(): String {
        return when {
            responseTimeSeconds < 0 -> "Time not tracked"
            responseTimeSeconds < 30 -> "Quick response (${responseTimeSeconds}s)"
            responseTimeSeconds < 120 -> "Moderate thinking (${responseTimeSeconds}s)"
            responseTimeSeconds < 300 -> "Thoughtful consideration (${responseTimeSeconds / 60}m)"
            else -> "Deep reflection (${responseTimeSeconds / 60}m)"
        }
    }

    companion object {
        /**
         * Maximum recommended response length Helps prevent extremely long
         * responses that might indicate overthinking
         */
        const val MAX_RECOMMENDED_LENGTH = 500

        /**
         * Minimum recommended response length Encourages users to provide
         * thoughtful responses
         */
        const val MIN_RECOMMENDED_LENGTH = 20

        /** Self-rating scale descriptions */
        val RATING_DESCRIPTIONS = mapOf(
            1 to "Poor - I could do much better",
            2 to "Fair - Some empathy shown",
            3 to "Good - Decent empathetic response",
            4 to "Great - Strong empathy demonstrated",
            5 to "Excellent - Very empathetic and supportive"
        )
    }
}